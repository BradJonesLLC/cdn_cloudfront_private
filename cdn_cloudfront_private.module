<?php

/**
 * @file Cloudfront private files implementation
 */

define('CDN_CLOUDFRONT_PRIVATE_PREFIX', 'protected');
define('CDN_CLOUDFRONT_PRIVATE_PUBLIC_STRING', '_public_');
define('CDN_CLOUDFRONT_PRIVATE_PUBLIC_PIPE', 'cdn_cloudfront_private/public');
define('CDN_CLOUDFRONT_PRIVATE_DOMAIN', 'cloudfront.net');

/**
 * Implements hook_file_url_alter()
 */
function cdn_cloudfront_private_file_url_alter(&$uri) {
  // We assume that CDN module has already done its thing. Default module weight
  // will normally guarantee this.
  if (file_uri_scheme($uri)) {
    // If we have a stream wrapper (and not just a path) and the admin user is allowed to
    // bypass file access, and we don't want CDN links on this Drupal path, then
    // serve the public file via a pipe. This cuts out the CDN but does add overhead.
    // The goal is to allow the admin to view content not delivered by the CDN
    // due to the Drupal path exclusion and not accessible directly due to .htaccess.
    if (!url_is_external($uri) && user_access('bypass file access') && !cdn_check_drupal_path(current_path()) && cdn_check_file($uri)) {
      // We are removing the scheme, which is OK in this limited scope.
      $uri = CDN_CLOUDFRONT_PRIVATE_PUBLIC_PIPE . '/' . file_uri_target($uri);
    }
    else if (url_is_external($uri) // External
            && (strpos(parse_url($uri, PHP_URL_HOST), CDN_CLOUDFRONT_PRIVATE_DOMAIN) !== FALSE) // Is CloudFront
            && (strpos($uri, CDN_CLOUDFRONT_PRIVATE_PUBLIC_STRING) === FALSE)) { // Needs a signed URL
      // Check access and generate a token.
      if (user_access('view private cloudfront files')) {
        $parts = parse_url($uri, PHP_URL_QUERY);
        $params = _cdn_cloudfront_private_custom_policy_params();
        if ($parts) {
          $params += _netbillilng_membership_parse_str_multiple($parts);
        }
        $uri = preg_replace('/\?.*/', '', $uri) . '?' . drupal_http_build_query($params);
      }
      else {
        // @todo - Handle exception condition. Site design should limit this.
      }
    }
  }
}

/**
 * Implements hook_permission()
 */
function cdn_cloudfront_private_permission() {
  return array(
    'view private cloudfront files' => array(
      'title' => t('Grant user a token to view private files on CloudFront CDN'),
    ),
  );
}

/**
 * Implements hook_menu()
 */
function cdn_cloudfront_private_menu() {
  $items = array();
  // @see system.module
  $items[CDN_CLOUDFRONT_PRIVATE_PUBLIC_PIPE] = array(
    'title' => 'Deliver public files via pipe directly, not via CDN',
    'page callback' => 'file_download',
    'page arguments' => array('public'),
    'access arguments' => array('bypass file access'),
    'type' => MENU_CALLBACK,
  );
  $items[CDN_CLOUDFRONT_PRIVATE_PUBLIC_PIPE . '/styles/%image_style'] = array(
    'title' => 'Generate image style',
    'page callback' => 'image_style_deliver',
    'page arguments' => array(count(explode('/', CDN_CLOUDFRONT_PRIVATE_PUBLIC_PIPE)) + 1),
    'access arguments' => array('bypass file access'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/development/cdn/cdn_cloudfront_private'] = array(
    'title' => 'CloudFront Private',
    'description' => t("Cloudfront private files config"),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cdn_cloudfront_private_admin_settings'),
    'access arguments' => array(CDN_PERM_ADMIN),
    'file' => 'cdn_cloudfront_private.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_transliteration_clean_filename_prepare_alter()
 *
 * Don't allow any incoming files to contain our public flag string - that's only for us.
 */
function cdn_cloudfront_private_transliteration_clean_filename_prepare_alter(&$filename, $source_langcode) {
  $filename = str_replace(CDN_CLOUDFRONT_PRIVATE_PUBLIC_STRING, '-public-', $filename);
}

/**
 * Implements hook_file_presave()
 */
function cdn_cloudfront_private_file_presave($file) {
  // This might be a new file and as such isn't set up as a file entity.
  if (empty($file->fid)) {
    return;
  }
  // Identify the file as allowing public access.
  $file_wrapper = entity_metadata_wrapper('file', $file);
  $is_public_file = ($file_wrapper->__isset('field_guest_access') && $file_wrapper->field_guest_access->value());
  if ($file_wrapper->field_guest_access->value() && !strpos($file->filename, CDN_CLOUDFRONT_PRIVATE_PUBLIC_STRING)) {
    $stream_wrapper = file_stream_wrapper_get_instance_by_uri($file->uri);
    $mimetype = $stream_wrapper->getMimetype($file->uri);
    $mapping = file_mimetype_mapping();
    $extension = array_search(array_search($mimetype, $mapping['mimetypes']), $mapping['extensions']);
    // We don't really need to munge since we are requiring an OK extension to begin with.
    $destination = $file->uri . '.' . CDN_CLOUDFRONT_PRIVATE_PUBLIC_STRING . '.' . $extension;
    // The file was already saved to disk; file_save() just calls hooks and writes to the DB.
    $stream_wrapper->rename($file->uri, $destination);
    $file->uri = $destination;
    $file->filename = drupal_basename($destination);
  }
  else if (strpos($file->filename, CDN_CLOUDFRONT_PRIVATE_PUBLIC_STRING) && !$is_public_file) {
    $original_filename = $file->filename;
    $file->filename = str_replace('.' . CDN_CLOUDFRONT_PRIVATE_PUBLIC_STRING . '.', '.', $file->filename);
    $destination = str_replace($original_filename, $file->filename, $file->uri);
    $stream_wrapper = file_stream_wrapper_get_instance_by_uri($file->uri);
    $stream_wrapper->rename($file->uri, $destination);
    $file->uri = $destination;
  }
}

/**
 * Implements hook_form_FORM_ID_alter()
 */
function cdn_cloudfront_private_form_file_entity_add_upload_multiple_alter(&$form, &$form_state, $form_id) {
  $form['upload']['#upload_location'] .= CDN_CLOUDFRONT_PRIVATE_PREFIX . '-bulk-original';
}

/**
 * Sign a CloudFront custom policy.
 *
 * @param $policy
 * @return string
 */
function _cdn_cloudfront_private_rsa_sha1_sign($policy) {
  $signature = "";

  // @todo - Better error here
  if (!$keyfile = variable_get('cdn_cloudfront_private_keyfile')) {
    return $signature;
  }
  $fp = fopen($keyfile, "r");
  $priv_key = fread($fp, 8192);
  fclose($fp);
  $pkeyid = openssl_get_privatekey($priv_key);
  openssl_sign($policy, $signature, $pkeyid);
  openssl_free_key($pkeyid);
  return $signature;
}

/**
 * Return the external IP (for circumstances where we are local).
 *
 * @return string External IP
 */
function _cdn_cloudfront_private_external_ip() {
  $ip = variable_get('cdn_cloudfront_private_external_ip');
  if (!$ip || ((REQUEST_TIME - variable_get('cdn_cloudfront_private_external_ip_last', 0)) > 60*60)) {
    $ip = file_get_contents('http://phihag.de/ip/');
    // @todo - Handle timeout or other failure. Not critical since this is only for development.
    variable_set('cdn_cloudfront_private_external_ip', $ip);
    variable_set('cdn_cloudfront_private_external_ip_last', REQUEST_TIME);
  }
  return $ip;
}

/**
 * Determine if a future timestamp is near expiry (within 10 minutes.)
 *
 * @param $timestamp
 * @return bool
 */
function _cdn_cloudfront_private_near_expiry($timestamp) {
  return $timestamp < (time() + (10*60));
}

/**
 * Provide custom policy parameters for access to the CloudFront CDN private files.
 *
 * @return array Array of parameters to add to the request
 */
function _cdn_cloudfront_private_custom_policy_params() {
  // Get an external IP for the host, if we are on a local development environment.
  $drupal_ip = ip_address();
  $ip_address = ($drupal_ip == '127.0.0.1') ? _cdn_cloudfront_private_external_ip() : $drupal_ip;
  // Statically cache with advanced form since we may call this very often.
  global $user;
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast = &drupal_static(__FUNCTION__);
  }
  $data = &$drupal_static_fast;
  // Generate parameters if they're not set or they expire within the next 10 minutes.
  // We don't check the statically cached time for near-expiry, since we're likely either
  // generating or pulling from cache.
  if (!isset($data[$user->uid][$ip_address])) {
    $cid = 'cdn_cloudfront_private_policy:' . $user->uid . '_' . $ip_address;
    $cache = cache_get($cid);
    if ($cache && !_cdn_cloudfront_private_near_expiry($cache->data['#expire'])) {
      $data[$user->uid][$ip_address] = $cache->data;

    }
    else {
      $expire = REQUEST_TIME + variable_get('cdn_cloudfront_private_token_duration', 60 * 60 * 5);
      $policy = json_encode(array(
        // Extra array is to get a square-bracket JSON "container" to match the AWS docs.
        'Statement' => array(array(
          // No Resource as we're granting blanket access.
          'Condition' => array(
            'DateLessThan' => array('AWS:EpochTime' => $expire),
            // At the time of development, CloudFront doesn't do IPv6.
            // @todo - IPv6 support.
            'IpAddress' => array('AWS:SourceIp' => $ip_address . '/32'),
          )
        ))
      ));

      $record = $data[$user->uid][$ip_address] = array(
        '#expire' => $expire,
        '#params' => array(
          'Policy' => _cdn_cloudfront_private_base64_encode($policy),
          'Signature' => _cdn_cloudfront_private_base64_encode(_cdn_cloudfront_private_rsa_sha1_sign($policy)),
          'Key-Pair-Id' => variable_get('cdn_cloudfront_private_key_id'),
        )
      );
      // @todo - Should we use our own cache table?
      cache_set($cid, $record, 'cache', $expire);
    }
  }
  return $data[$user->uid][$ip_address]['#params'];
}

/**
 * Encodes a string into Base64 and sanitizes.
 *
 * Similar to drupal_base64_encode but the replacements are different.
 *
 * @param $string String to sanitize
 * @return string Sanitized string
 */
function _cdn_cloudfront_private_base64_encode($string) {
  $data = base64_encode($string);
  // @see http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html
  return strtr($data, array('+' => '-', '/' => '~', '=' => '_'));
}
