<?php

/**
 * @file Cloudfront private files implementation
 */

use Drupal\cdn_cloudfront_private\CdnCloudfrontPrivateEvents;
use Drupal\cdn_cloudfront_private\Event\CdnCloudfrontPrivateEvent;
use Drupal\Component\Utility\UrlHelper;

/**
 * Implements hook_file_url_alter()
 */
function cdn_cloudfront_private_file_url_alter(&$uri) {
  /** @var \Drupal\cdn_cloudfront_private\CdnCloudfrontPrivateManager $manager */
  $manager = \Drupal::service('cdn_cloudfront_private.manager');

  // We assume that CDN module has already done its thing. Default module weight
  // will normally guarantee this. However, we're not guaranteeing the uri is
  // necessarily a cloudfront URL, that's up to implementing event subscribers.
  $event = new CdnCloudfrontPrivateEvent($uri);
  $event->setPolicyStatement($manager::DEFAULT_POLICY_STATEMENT);
  \Drupal::service('event_dispatcher')->dispatch(CdnCloudfrontPrivateEvents::DETERMINE_URI_PROTECTION, $event);

  if (!$event->isProtected()) {
    return;
  }
  if (!UrlHelper::isExternal($event->getUri())) {
    throw new \Exception('Cannot sign a non-external URL for Cloudfront.');
  }

  // Signed URLs are likely not cacheable (if they are targeted for a user)
  // so while this is a blunt instrument, there's currently no cache metadata
  // for the generated file URL.
  // @see https://github.com/BradJonesLLC/cdn_cloudfront_private/issues/1
  if (!$event->isPageCacheable()) {
    \Drupal::service('page_cache_kill_switch')->trigger();
  }

  $uri = $manager->getSignedUrl($event->getUri(), $event->getPolicyStatement());
}
